
# 第5章：データモデリングと正規化

## 🎯 章の目的
データベース設計において、実用的かつ拡張性の高いデータモデルを作成するために、概念設計・正規化・物理設計・リレーション設計の基本とアンチパターンを理解する。

---

## 1. 概念設計とER図

### ✅ データモデリングとは
- 要件分析から導かれる**現実世界の構造**をデータとして表現
- エンティティ（実体）、リレーションシップ（関係）、属性に分解して設計

### 🧩 ER図要素の整理
- **エンティティ**: ユーザー、商品、注文など
- **属性**: ユーザー名、メールアドレス、価格など
- **主キー（PK）**: 一意に識別する属性
- **外部キー（FK）**: 他テーブルの主キーを参照する属性

--

# 追加：1. 概念設計とER図の構成要素（詳細解説）

## ✅ エンティティ（Entity）

- 現実世界の「物」や「人」など、データとして管理する対象
- テーブル1つに対応するイメージ
- 例：ユーザー、商品、注文、社員

**ER図での表現**：四角形

---

## ✅ リレーションシップ（Relationship）

- エンティティ同士のつながり・関係を表現
- 例：「顧客が注文する」「学生が講義を履修する」

**ER図での表現**：ひし形

**関係の型**：
| 種類 | 説明           | 例                   |
|------|----------------|----------------------|
| 1対1 | 一方が一方に対応 | 社員 ↔ 社員証       |
| 1対多| 一方が複数を持つ | 顧客 → 複数の注文   |
| 多対多| 両方が複数対応 | 学生 ↔ 講義（中間） |

---

## ✅ 属性（Attribute）

- エンティティやリレーションシップが持つ具体的な項目
- 例：名前、メールアドレス、生年月日など

**ER図での表現**：楕円形（円）

**属性の分類例**：
- 単純属性：名前、年齢など
- 複合属性：住所（都道府県＋市区町村＋番地）
- 派生属性：年齢（生年月日から算出）

---

## ✅ 主キー（Primary Key）

- 各レコードを一意に識別する属性
- テーブルに必須、NULL不可、重複不可

**例**：
- ユーザーID（user_id）
- 注文ID（order_id）

**ER図での表現**：下線付き属性（ERDツールによる）

---

## ✅ 外部キー（Foreign Key）

- 他のテーブルの主キーを参照するキー
- テーブル同士の関係をつなぐ役割を持つ

**例**：
- 注文テーブルの `user_id` → ユーザーテーブルの `id` を参照

---

## ✅ 用語まとめ表

| 用語         | 意味                                      | ER図表記 |
|--------------|-------------------------------------------|----------|
| エンティティ | 現実世界の管理対象（人・物・概念）        | 四角形   |
| リレーション | エンティティ同士の関係                     | ひし形   |
| 属性         | エンティティや関係の具体的なデータ項目     | 楕円形   |
| 主キー       | レコードを一意に識別するためのキー         | 下線付き属性（ER図上） |
| 外部キー     | 他テーブルの主キーを参照するためのキー     | 実装上テーブル間参照関係で示す |

---

## 2. 論理設計と物理設計

### ✅ 論理設計
- ER図を**リレーショナルスキーマ**へ変換
- 主キー、外部キー、ユニーク制約、NOT NULL制約などを明確に

### ✅ 物理設計
- DBMSに応じた最適化：インデックス、データ型、正規化度の調整など
- パフォーマンス、バックアップ、アクセス頻度を考慮した設計

---

## 3. 正規化の理論と実践

### ✅ 正規化の目的
- 冗長なデータを排除して**整合性を維持**
- 更新異常、削除異常、挿入異常を防ぐ
- 保守のしやすさのため

### ✅ 正規化の手順（簡略）

1. **1NF（第一正規形）**: 繰り返し属性・複数値を排除（テーブルは原子値のみ）
2. **2NF（第二正規形）**: 複合キーの**部分関数従属**を排除（主キーの一部にしか依存しない列を分離）
3. **3NF（第三正規形）**: **推移的関数従属**の排除（キー以外の列に依存する列を分離）
4. **BCNF（ボイス・コッド正規形）**: すべての関数従属の左辺が候補キーになるように

---

## 4. 正規化の具体例（図付き）

### 繰り返しが排除されていないテーブルの例
| 書籍ID | 書籍名 | 著者1 | 著者2 | 単価 | 出版社 |
|--------|--------|----------|--------|------|--------|
| 1      | SQL入門   | 佐藤     | 高橋  | 1000 | 技術評論社 |
| 2      | JavaScript入門   | 田中     | Null  | 2000 | オライリー |

### 繰り返しを排除したテーブル
| 書籍ID | 書籍名 | 著者1 | 単価 | 出版社 |
|--------|--------|----------|------|--------|
| 1      | SQL入門   | 佐藤     | 1000 | 技術評論社 |
| 1      | SQL入門   | 高橋     | 1000 | 技術評論社 |
| 2      | JavaScript入門   | 田中  | 2000 | オライリー |

### 主キーの一部に依存するデータを別テーブルへ
## 書籍テーブル
| 書籍ID | 書籍名 | 単価 | 出版社 |
|--------|--------|----------|------|
| 1      | SQL入門   | 1000 | 技術評論社 |
| 2      | JavaScript入門   | 2000 | オライリー |

## 著者テーブル
| 書籍ID | 著者1 |
|--------|--------|
| 1      | 佐藤    |
| 1      | 高橋    |
| 2      | 田中    |

### 主キーの一部に依存するデータを別テーブルへ
## 書籍テーブル
| 書籍ID | 書籍名 | 単価 | 出版社 |
|--------|--------|----------|------|
| 1      | SQL入門   | 1000 | 技術評論社 |
| 2      | JavaScript入門   | 2000 | オライリー |

## 著者テーブル
| 書籍ID | 著者1 | 単価 | 出版社 |
|--------|--------|----------|------|
| 1      | 佐藤     | 1000 | 技術評論社 |
| 1      | 高橋     | 1000 | 技術評論社 |
| 2      | 田中  | 2000 | オライリー |

### 主キーの一部に依存するデータを別テーブルへ
## 書籍テーブル
| 書籍ID | 書籍名 | 単価 | 出版社ID |
|--------|--------|----------|------|
| 1      | SQL入門   | 1000 | 1 |
| 2      | JavaScript入門   | 2000 | 2 |

## 出版社テーブル
| 出版社ID | 出版社 |
|--------|--------|
| 1      | 技術評論社 |
| 2      | 技術評論社 |



# ボイス・コッド正規形（BCNF: Boyce-Codd Normal Form）

ボイス・コッド正規形（BCNF）は、第三正規形（3NF）よりも少し厳しい正規化のルールです。
第三正規形を満たしていてもある条件下では冗長性が残る場合があり、それを解消するのがBCNFです。

---

## ✅ BCNFの定義

> **すべての関数従属において、決定項（左辺）が候補キーであること**

---

## 🔁 関数従属とは？

「A → B」というとき、Aが決まればBも一意に決まる関係です。

例：社員ID → 氏名（社員IDが分かれば氏名も特定できる）

---

## 🧠 第三正規形との違い

| 観点             | 第三正規形 (3NF)       | BCNF                              |
|------------------|-------------------------|-----------------------------------|
| 対象とする従属   | 推移的従属を排除        | 候補キーでない決定項も排除       |
| 許される例外     | 非キー属性が決定項ならOK | 一切の例外を認めない             |

BCNFは、**すべての決定項が候補キーであることを要求**します。
→ 候補キー以外が何かを決定することは許されません。

---

## 📘 例：3NFだがBCNFでないパターン

### ✏️ テーブル：大学の教室割り当て

| 教員   | 教室 | 講義         |
|--------|------|--------------|
| A教授 | 101  | データベース |
| A教授 | 101  | 情報理論     |
| B教授 | 102  | OS           |

### 関数従属の関係：

- 教員 → 教室（教授がいつも同じ教室を使う）
- {教員, 講義} → 教室（複合キーで教室が特定される）

このとき：

- 主キー候補：`{教員, 講義}`
- しかし `教員 → 教室` のように、**主キーでない属性が他を決定**している（NG）

---

## ✅ BCNFに分解する

### 分解後：

#### 教員表

| 教員   | 教室 |
|--------|------|
| A教授 | 101  |
| B教授 | 102  |

#### 講義表

| 教員   | 講義         |
|--------|--------------|
| A教授 | データベース |
| A教授 | 情報理論     |
| B教授 | OS           |

→ 教員が使う教室と、教員が担当する講義が分離され、**冗長性が解消**される

---

## 🧪 まとめ

| 項目         | 内容 |
|--------------|------|
| 正規化段階   | 第4段階（1NF → 2NF → 3NF → BCNF） |
| 目的         | すべての関数従属の決定項を候補キーにする |
| 例外の有無   | 一切なし（厳格） |
| 利点         | 複雑な関係でもデータの整合性と非冗長性を保てる |


---

### ✅ 正規化手順

#### → 第1正規形：著者を分割し1行1商品に

#### → 第2正規形：書籍IDにのみ依存しない「著者情報」を分離

#### → 第3正規形：書籍テーブルの出版社IDが出版社テーブルの主キーになる

---

## 5. 非正規化の判断基準と活用

### ✅ 非正規化とは
- 正規化された構造を**一部わざと冗長化**することで性能向上を図る
- JOINの回数削減や集計高速化が目的

### ✅ 非正規化の典型例
- 頻繁に使う項目のキャッシュ列をテーブルに追加
- 外部キーの参照元の一部情報（名前など）を持たせる
- 集計列（注文数、平均など）をテーブルに保持

### 頻繁に使う項目のキャッシュ列をテーブルに追加
| 書籍ID | 書籍名 | 著者名 |
|--------|--------|----------|
| 1      | SQL入門   | 佐藤     |
| 2      | JavaScript入門   | 田中     |

- **利点**：JOINせずに出版社名を表示できる（画面表示が高速）
- **欠点**：出版社名が変更されたとき、複数テーブルを更新する必要あり

---

### 外部キーの参照元の一部情報（名前など）を持たせる

### 🔽 正規化構造：著者情報は著者テーブルで管理

**書籍テーブル**

| 書籍ID | 書籍名 |
|--------|--------|
| 1      | SQL入門 |
| 2      | JavaScript入門 |

**著者テーブル**

| 書籍ID | 著者名 |
|--------|--------|
| 1      | 佐藤    |
| 1      | 高橋    |
| 2      | 田中    |

### 🔁 非正規化例：書籍テーブルに代表著者名を含める

| 書籍ID | 書籍名 | 代表著者 |
|--------|--------|------------|
| 1      | SQL入門 | 佐藤       |
| 2      | JavaScript入門 | 田中 |

- **利点**：代表著者名を素早く表示可能（検索・ソートにも便利）
- **欠点**：著者情報が更新された場合、冗長な箇所すべてに対応が必要

---

## ③ 集計列（注文数、平均など）をテーブルに保持

### 🔽 正規化構造：注文は別テーブルで管理し、都度集計

**注文テーブル**

| 注文ID | 書籍ID | 個数 |
|--------|--------|------|
| 1      | 1      | 2    |
| 2      | 1      | 1    |
| 3      | 2      | 3    |

### 🔁 非正規化例：書籍テーブルに合計注文数を追加

| 書籍ID | 書籍名 | 注文数合計 |
|--------|--------|-------------|
| 1      | SQL入門 | 3           |
| 2      | JavaScript入門 | 3     |

- **利点**：頻繁な集計を避け、ページ表示速度が向上
- **欠点**：注文が入るたびに書籍テーブルの注文数も更新する必要がある（整合性維持の工夫が必要）

---

## 6. 設計のアンチパターン

| アンチパターン名 | 説明 | 問題点 |
|------------------|------|--------|
| 一覧カラム        | 複数値を1列にカンマ区切りで保存 | 検索・正規化困難 |
| マスタハードコード | 状態や区分を数字にしてアプリ内で意味付け | 可読性・保守性が低い |
| 汎用カラム         | 目的が異なるデータを同一カラムに格納 | 意味の不明瞭化 |
| すべて文字列       | 整数や日付もVARCHARで保存 | データ不整合・パフォーマンス低下 |
| 外部キー不使用     | 関連データ間に制約を設けない | 整合性が保証されない |

---

## 7. リレーションシップ設計パターン

### 1対1の例

```sql
CREATE TABLE User (
  id INT PRIMARY KEY,
  name VARCHAR(100)
);

CREATE TABLE UserProfile (
  user_id INT PRIMARY KEY,
  birthdate DATE,
  FOREIGN KEY (user_id) REFERENCES User(id)
);
```

### 多対多の例（中間テーブル）

```sql
CREATE TABLE StudentCourse (
  student_id INT,
  course_id INT,
  PRIMARY KEY (student_id, course_id),
  FOREIGN KEY (student_id) REFERENCES Student(id),
  FOREIGN KEY (course_id) REFERENCES Course(id)
);
```

---

## ✅ まとめ

```
✔ データ設計は「意味に基づいた分解と構造化」が鍵
✔ 正規化は異常防止、非正規化は性能最適化
✔ 設計アンチパターンを避けることで、長期的な保守性が向上する
```

