# 6. トランザクションとACID特性

# 6.1. トランザクションとは何か

### 処理の「All or Nothing」を保証する論理的な作業単位
トランザクションとは、データベースに対する一連の操作（一つ以上のSQL文）をひとまとめにした、論理的な処理単位のことです。

トランザクションの最も重要な特性は「原子性（Atomicity）」であり、これは「All or Nothing（すべて実行されるか、一切実行されないか）」の原則を保証することを意味します 。つまり、トランザクションに含まれる全ての操作が成功した場合にのみ、その結果がデータベースに恒久的に保存されます。

もし一連の操作の途中で何らかのエラーや障害が発生した場合は、それまでに行われた全ての操作が取り消され、データベースはトランザクションが開始される前の状態に完全に戻されます。

この仕組みにより、中途半端な更新処理によってデータが矛盾した状態に陥ることを防ぎます。

### 具体例：銀行振込処理の舞台裏
トランザクションの概念を具体的に理解するために、銀行の口座振込処理を考えてみましょう。

Aさんの口座からBさんの口座へ1万円を送金する場合、システム内部では少なくとも以下の二つの操作が必要です。   

1. Aさんの口座残高から1万円を減らす（UPDATE文）

2. Bさんの口座残高に1万円を加算する（UPDATE文）

もし、1の処理が成功した直後にシステム障害が発生し、2の処理が実行されなかった場合、Aさんの口座から1万円が消えたにもかかわらず、Bさんの口座には入金されません。

これは、全体として1万円が消失したことを意味し、データの整合性が完全に崩壊した状態です。しかし、これら二つの操作を一つのトランザクションとしてまとめることで、DBMSはその「All or Nothing」を保証します。

障害が発生すれば、Aさんの口座から1万円を減らす操作も自動的に取り消され、お金が消えるという事態を防ぐことができるのです。

このようにトランザクションは、現実世界のビジネスルールをデータベース上で安全に実現するための不可欠な仕組みです。

<img width="846" height="616" alt="スクリーンショット 2025-08-17 21 32 23" src="https://github.com/user-attachments/assets/598d0b2d-a811-4b80-baa2-01a567d1a46b" />


### `COMMIT` と `ROLLBACK` 変更の確定と破棄
トランザクションのライフサイクルは、二つの基本的なコマンドによって制御されます。

- `COMMIT`

  トランザクション内の全ての操作が正常に完了したことを宣言し、その変更をデータベースに恒久的に反映させる命令です。
  COMMITが実行されると、変更内容は確定し、他のトランザクションからも参照可能になります。

- `ROLLBACK`

  トランザクション内でエラーが発生した場合や、処理を意図的に中断したい場合に、それまでに行った全ての変更を破棄し、データベースをトランザクション開始前の状態に戻す命令です 。これが「Nothing」の部分を強制するメカニズムです。   

開発者は、一連のビジネスロジックの成功をもって`COMMIT`を実行し、途中で問題が検知された場合には`ROLLBACK`を実行することで、データの整合性を能動的に管理します。


# 6.2 ACID特性の詳細：信頼性の四原則
トランザクションがデータベースの信頼性を保証するために備えるべき4つの重要な性質は、それぞれの頭文字をとってACID特性と呼ばれます。

これらの特性は、データベースシステムが予期せぬ障害やエラーに直面しても、データの完全性を維持するための基盤となります 。

ここでは、料理教室の例えを用いて直感的なイメージを掴んだ後、各特性を技術的に詳述します 。   

- 原子性 (Atomicity): レシピの全工程を完璧にこなすこと。途中で失敗したら最初からやり直し。

- 一貫性 (Consistency): 教室のルール（アレルギー食材は使わない等）を常に守ること。

- 独立性 (Isolation): 他の生徒の作業が自分の料理に影響を与えないこと。

- 永続性 (Durability): 完成した料理を冷蔵庫にしっかり保存し、失われないようにすること。

## 6.2.1 Atomicity (原子性): 不可分な操作
- 定義と技術的実現

  原子性とは、前述の通りトランザクションが「All or Nothing」で実行されることを保証する性質です。

  技術的には、これは主にトランザクションログを用いて実現されます。

  データベース本体のデータを直接変更する前に、まず「これからどのような変更を行うか」という操作内容をログファイルに記録します。

  もしトランザクションが中断（アボート）された場合、DBMSはこのログを逆方向に辿り、実行された操作を取り消す（UNDO）ことで、データベースを矛盾のない状態に戻します 。   

- シナリオ(原子性が失われた場合の問題点)

  銀行振込の例で原子性が保証されない場合、送金元口座からの引き落としは完了したが、システムクラッシュにより送金先口座への入金が行われないという事態が発生します。

  結果として、顧客の資産が失われ、データベースは不整合な状態に陥ります。原子性は、トランザクションにおける整合性の最も基本的な保証です。

## 6.2.2 Consistency (一貫性): 常に正しい状態へ
- 定義とデータベース制約との関係

  一貫性とは、トランザクションの実行前後において、データベースが常に「正当な（valid）」状態を維持することを保証する性質です 。
  
  これは他の3つの特性よりも広範な概念であり、データの値がデータベースに予め定義されたルールや制約（例：NOT NULL制約、一意性制約、外部キー制約、CHECK制約など）を常に満たしていることを意味します 。

  トランザクション自体がビジネスロジックとして正しく記述されていることが前提であり、データベースはその正しいトランザクションが実行された結果、データ全体の整合性が保たれることを保証します。   

- シナリオ(一貫性が崩壊する例)

  例えば、商品の在庫が5つしかないのに10個の注文を受け付けるトランザクションや、存在しない顧客IDに対して注文を作成するトランザクションは、一貫性を破壊します。
  
  適切に設計されたデータベースでは、在庫数に対するCHECK制約や、顧客テーブルへの外部キー制約によってこのような不正なトランザクションは拒否され、一貫性が維持されます。

  一貫性は、データベースが提供するA, I, Dという仕組みと、開発者が記述する正しいビジネスロジックとの共同責任によって達成される目標と言えます。

## 6.2.3 Isolation (独立性): 干渉からの保護
- 定義と同時実行の問題

  独立性（分離性とも呼ばれる）は、複数のトランザクションが同時に実行されたとしても、互いに干渉することなく、あたかも各トランザクションが単独で実行されているかのように振る舞うことを保証する性質です 。
  
  これは、特に多人数が同時にシステムを利用する環境において、データの破損を防ぐために極めて重要です。  

- シナリオ(独立性が確保されない場合のデータ破損)

  航空券予約システムで、最後の1席を2人のユーザーが同時に予約しようとするケースを考えます。
  
  独立性がなければ、両方のトランザクションが「残席1」という情報を読み取り、それぞれが予約を成功させてしまう可能性があります。結果として、座席はダブルブッキングされ、航空会社は深刻な問題に直面します。

  独立性はこの問題を、一方のトランザクションが完了して座席を確保するまで、もう一方のトランザクションからはその途中経過が見えないようにすることで防ぎます。   

## 6.2.4 Durability (永続性): 失われない結果
- 定義と物理的保存の保証

  永続性とは、一度`COMMIT`されたトランザクションの結果は、その後にシステム障害（例：電源断、OSクラッシュ）が発生したとしても失われることはなく、恒久的にデータベースに保存されることを保証する性質です 。
  
  これは、トランザクションの変更内容が、`COMMIT`の成功をクライアントに通知する前に、ディスクなどの不揮発性ストレージ上のログファイルに書き込まれることで実現されます 。

- シナリオ(永続性がなければ何が起こるか)

  ユーザーがオンラインショッピングで注文を確定し、システムから「注文完了」の通知を受け取ったとします。
  
  その直後にサーバーが停電した場合、永続性がなければ、サーバー再起動後にその注文データが消失している可能性があります。

  しかし、ユーザーのクレジットカード決済は既に処理されているかもしれません。

  永続性は、一度確定した注文情報が確実に保存されることを保証し、このような悲惨な事態を防ぎます 。


# 6.3 同時実行制御とロック機構

## 6.3.1 なぜ同時実行制御が必要なのか？
複数のトランザクションを一つずつ順番に実行（直列実行）すれば、独立性は完全に保証されます。

しかし、それではシステムの処理性能が極端に低下し、多くのユーザーが同時に利用する現代のアプリケーションでは現実的ではありません。

同時実行制御とは、複数のトランザクションを並行して実行させつつ、ロックなどの仕組みを用いて互いの干渉を防ぎ、あたかも直列に実行されているかのような結果の正しさを保証するための技術です。

これにより、システムのパフォーマンスとデータ整合性の両立を図ります 。   

## 6.3.2 ロックの基本：共有ロック (Shared Lock) と専有ロック (Exclusive Lock)
同時実行制御の最も基本的な仕組みがロックです。

ロックは、あるトランザクションがデータにアクセスしている間、他のトランザクションからのアクセスを制限することで排他制御を実現します 。   

- 共有ロック (Shared Lock / S-Lock)

  データを読み取る際に獲得するロックです。
  
  「読み取りロック」とも呼ばれます。共有ロックは他のトランザクションが同じデータに対して共有ロックを獲得することを許可しますが、専有ロックの獲得はブロックします。
  
  つまり、複数のユーザーが同時に同じデータを読み取ることはできます。

- 専有ロック (Exclusive Lock / X-Lock)

  データを変更（INSERT, UPDATE, DELETE）する際に獲得するロックです。
  
  「書き込みロック」とも呼ばれます。専有ロックがかけられているデータに対しては、他のトランザクションは共有ロックも専有ロックも獲得できず、読み書き両方がブロックされます 。   

この二つのロックの互換性（Sロック同士は両立するが、Xロックは他のいかなるロックとも両立しない）が、データベースにおける排他制御の根幹をなしています 。   

## 6.3.3 悲観的並行制御 (Pessimistic Concurrency Control)
- 思想：「衝突は起こるもの」
  
  悲観的ロックは、トランザクション間でデータ更新の競合が頻繁に発生するという前提に立つアプローチです。
  
  そのため、データを変更する前にまず対象のデータをロックし、他のトランザクションがアクセスできないようにしてから処理を開始します。
  
  競合の発生を悲観的に予測し、未然に防ぐための手法です 。   

- 実装例(`SELECT... FOR UPDATE`の詳細な解説)

  悲観的ロックを実装する最も一般的な方法は、`SELECT... FOR UPDATE`構文を使用することです。
  
  このSQL文は、データを読み取ると同時に、その行に対して専有ロック（X-Lock）を獲得します。

  これにより、現在のトランザクションが`COMMIT`または`ROLLBACK`するまで、他のトランザクションは対象行を変更したり、同様にロックをかけたりすることができなくなります 。   

<img width="786" height="228" alt="スクリーンショット 2025-08-19 0 51 13" src="https://github.com/user-attachments/assets/7d5d6e6b-9533-4110-bf2a-b6c660a7f922" />


この構文は必ずトランザクションブロック内で使用する必要があり、ロックの保持時間を最小限にするため、処理が完了したら速やかにトランザクションを終了することが重要です。

また、WHERE句の条件がインデックスを利用しない場合、行ロックではなくテーブル全体がロックされてしまう危険性があるため、インデックス設計が極めて重要になります 。   

## 6.3.4 楽観的並行制御 (Optimistic Concurrency Control)
- 思想：「衝突は稀である」

  楽観的ロックは、データ更新の競合はめったに発生しないという前提に立つアプローチです。
  
  そのため、データ読み取り時にはロックをかけません。代わりに、読み取ったデータを実際に更新しようとする段階で、そのデータが他のトランザクションによって変更されていないかを確認します。
  
  競合の発生を楽観的に捉え、もし発生していた場合にそれを検知する手法です 。   

- 実装例：バージョンカラムを用いた更新手法:

  楽観的ロックの一般的な実装パターンは、バージョン管理カラムを使用する方法です。

1. 対象のテーブルに`version`のような整数型のカラムを追加します 。   

2. アプリケーションがデータを読み込む際、`version`カラムの値も一緒に取得します。

3. データを更新する際、`UPDATE`文の`WHERE`句に、読み込み時と同じ`version`番号であることを条件として加えます。

4. `UPDATE`文では、`version`カラムの値を1つインクリメントします。

<img width="782" height="195" alt="スクリーンショット 2025-08-19 0 57 07" src="https://github.com/user-attachments/assets/4fc4549a-7296-42b0-8653-801381c67ec0" />


もしこのUPDATE文の実行結果が1行更新であれば、競合は発生しておらず、更新は成功です。

もし結果が0行更新であれば、読み込んでから更新するまでの間に他のトランザクションがデータを更新し、version番号が変わってしまったことを意味します。

この場合、更新は失敗したと判断し、アプリケーションはトランザクションをロールバックして、データの再読み込みから処理をやり直す（リトライする）必要があります。   

悲観的ロック vs 楽観的ロック 比較表

<img width="679" height="181" alt="スクリーンショット 2025-08-19 0 58 10" src="https://github.com/user-attachments/assets/1deee01c-8721-4c8b-8089-955ca944b0d8" />



# 6.4 分離レベル (Isolation Level)

## 6.4.1 データベースの分離レベル（Isolation Level）とは？
データベースでは、複数のトランザクションが同時に実行される（並行処理）のが一般的です。

このとき、何も制御がないと、他のトランザクションが中途半端に書き換えたデータを読んでしまったり、一貫性のない状態に陥ったりする問題が発生します。

分離レベルとは、**「あるトランザクションの処理中に、他のトランザクションによる変更をどの程度まで許容するか」** を定義する設定です。

分離レベルは、データの整合性とシステムのパフォーマンス（同時実行性）がトレードオフの関係にあります。

- レベルを高くする（厳しくする）

  データの整合性は非常に高まるが、ロックの範囲や期間が長くなり、他のトランザクションが待たされるためパフォーマンスは低下する。

- レベルを低くする（緩くする）

  トランザクションの待ち時間が減り、パフォーマンスは向上するが、後述するようなデータ不整合の問題が発生するリスクが高まる。

## 6.4.2 分離レベルを理解するための３つの問題（Anomaly）
分離レベルを語る上で、まず「どのような問題が起こりうるのか」を理解することが重要です。

1. ダーティリード (Dirty Read)

   - 内容 まだコミットされていない、他のトランザクションによる変更途中のデータを読み込んでしまう現象。
     
   - リスク: 読み込んだデータが後でロールバックされる可能性があるため、全く存在しなかったはずのデータを元に処理を進めてしまう危険性がある。

2. ノンリピータブルリード / ファジーリード (Non-Repeatable Read / Fuzzy Read)
   - 内容: １つのトランザクション内で同じレコードを複数回読み込んだ際に、結果が異なってしまう現象。
   
   - 原因: １回目の読み込み後、別のトランザクションがそのレコードを更新(UPDATE)してコミットしてしまうため。

3. ファントムリード (Phantom Read)
   - 内容: １つのトランザクション内で特定の範囲のレコードを複数回読み込んだ際に、１回目には存在しなかったレコードが２回目に出現する（またはその逆）現象。まるで幽霊（Phantom）のようにレコードが現れることから名付けられた。
   
   - 原因: １回目の読み込み後、別のトランザクションがその範囲内にレコードを挿入(INSERT)または削除(DELETE)してコミットしてしまうため。
  
## 6.4.3 標準的な４つの分離レベル
1. READ UNCOMMITTED (リード・アンコミッティド)
   - 概要: 最も低い分離レベル。他のトランザクションがコミットしていない変更でも読み取ることができてしまう。
   
   - 防げる問題: なし。
   
   - 発生しうる問題: ダーティリード、ノンリピータブルリード、ファントムリード。
   
   - 仕組み: データを読み取る際にロックを全くかけません。そのため、他のトランザクションによるロックを待つことなく、最も高速に動作します。
   
   - ユースケース: データの厳密な整合性が求められない、おおよその集計値を知りたい場合や、システムの監視など。実用上、このレベルが選択されることは稀です。

ダーティリードの発生する具体例

<img width="583" height="337" alt="スクリーンショット 2025-08-20 1 05 33" src="https://github.com/user-attachments/assets/5d68dc8d-2f57-4279-809b-f500d6a418ab" />


2. READ COMMITTED (リード・コミッティド)
   - 概要: 多くのデータベース（Oracle, PostgreSQL, SQL Serverなど）でデフォルトとなっている分離レベル。コミットされたデータのみを読み取る。
   
   - 防げる問題: ダーティリード。
   
   - 発生しうる問題: ノンリピータブルリード、ファントムリード。
   
   - 仕組み: データを読み取るその瞬間だけ共有ロック（Read Lock）をかけるか、MVCC（Multi-Version Concurrency Control）という仕組みを利用して、ステートメント開始時点のコミット済みデータを読み取ります。これにより、ダーティリードを防ぎます。しかし、ロックはすぐに解放されるため、別のトランザクションによる更新や挿入は可能です。
   
   - ユースケース: 一般的なWebアプリケーションなど、多くのシステムで採用されるバランスの取れたレベルです。

リード・コミッティドの発生する具体例

<img width="587" height="352" alt="スクリーンショット 2025-08-20 1 06 06" src="https://github.com/user-attachments/assets/38c16ea5-117d-46ba-b3ee-46a2bc29f951" />


3. REPEATABLE READ (リピータブル・リード)
   - 概要: MySQL (InnoDB) のデフォルトとなっている分離レベル。一つのトランザクション内では、何度同じレコードを読み込んでも同じ結果が返ることを保証する。
   
   - 防げる問題: ダーティリード、ノンリピータブルリード。
   
   - 発生しうる問題: ファントムリード。
   
   - 仕組み: トランザクションが開始された時点のデータのスナップショットを作成します（MVCC）。そのトランザクション内での読み取りは、常にそのスナップショットに対して行われます。これにより、他のトランザクションが途中でデータを更新・コミットしても、その影響を受けません。ただし、範囲を指定した検索の場合、他のトランザクションによる行の挿入までは防げないため、ファントムリードが発生します。
   
   - ユースケース: 一つの処理の中で、同じデータを参照しながら整合性の取れた更新を行いたい場合など。

リピータブル・リードの発生する具体例

<img width="577" height="445" alt="スクリーンショット 2025-08-20 1 06 40" src="https://github.com/user-attachments/assets/004cce8e-f72e-4457-987e-ef261153f53e" />



4. SERIALIZABLE (シリアライザブル)
   - 概要: 最も高い分離レベル。トランザクションを一つずつ順番に実行したのと同じ結果を保証する。
   
   - 防げる問題: ダーティリード、ノンリピータブルリード、ファントムリード。全ての問題を防ぎます。
   
   - 仕組み: 非常に強力なロック機構を用います。SELECT で読み取ったレコードだけでなく、範囲（Gap Lock, Next-Key Lock） にもロックをかけ、他のトランザクションがその範囲にデータを挿入することすらブロックします。
   
     これによりファントムリードを防ぎますが、同時実行性が大幅に低下するため、性能への影響が最も大きくなります。

   - ユースケース: 預金残高の計算や在庫の引き当て処理など、絶対にデータ不整合が許されない、極めて高い信頼性が要求されるミッションクリティカルな処理。

シリアライザブルが防がれる具体例

<img width="579" height="382" alt="スクリーンショット 2025-08-20 1 07 24" src="https://github.com/user-attachments/assets/7761a763-c4e2-4f52-a142-be72584d2fa3" />


分離レベルと発生する問題の対応表

<img width="504" height="152" alt="スクリーンショット 2025-08-20 1 01 18" src="https://github.com/user-attachments/assets/7c81662f-0dc0-491d-8be2-60e41af074e1" />


## 6.4.4 分離レベルの設定方法

### 分離レベルの設定方法
標準SQLでは、以下のようにトランザクションごとに分離レベルを設定できます。

データベース全体やセッション単位でのデフォルト設定も可能です。

<img width="585" height="221" alt="スクリーンショット 2025-08-20 1 02 44" src="https://github.com/user-attachments/assets/a5dcc5df-a5e0-4cf9-90b4-1ccfeaefd3d7" />


### どのレベルを選ぶべきか？

特別な理由がない限り、まずは**データベースのデフォルト設定（READ COMMITTED または REPEATABLE READ）** を利用するのが基本です。

その上で、アプリケーションの要件でどうしても不整合が許されない特定の処理がある場合にのみ、トランザクション単位でレベルを上げる（例: SERIALIZABLEにする）ことを検討しましょう。

パフォーマンスへの影響を常に意識することが重要です。


# 6.5 デッドロックとその対処法

### デッドロックの発生メカニズム
デッドロックとは、2つ以上のトランザクションが、互いに相手が保持しているロックの解放を待ち続けることで、永久に処理が進まなくなってしまう状態のことです。

この膠着状態は、以下のような典型的なシナリオで発生します。   

1. トランザクションAが、リソースX（例：productsテーブルの行1）のロックを獲得する。

2. ほぼ同時に、トランザクションBが、リソースY（例：stockテーブルの行5）のロックを獲得する。

3. トランザクションAが、次にリソースYのロックを獲得しようとするが、Bが保持しているため待機状態に入る。

4. トランザクションBが、次にリソースXのロックを獲得しようとするが、Aが保持しているため待機状態に入る。

この結果、AはBの終了を待ち、BはAの終了を待つという循環的な待ち状態が生まれ、どちらのトランザクションも外部からの介入なしには進むことができなくなります。

## 6.5.1 デッドロックの予防策
デッドロックへの最善の対処法は、そもそもデッドロックが発生しにくいシステムを設計することです。   

- リソース取得順序の統一

  これが最も効果的な予防策です。
  
  複数のリソースをロックする必要がある場合、全てのトランザクションが必ず同じ順序（例：常にテーブルA→テーブルBの順）でロックを取得するようにアプリケーションを設計します。
  
  これにより、前述のような循環的な待ち状態が発生するのを防ぐことができます 。   

- トランザクションの短期化とスコープの最小化

  トランザクションがロックを保持する時間が短ければ短いほど、他のトランザクションと衝突する機会は減ります。
  
  一つのトランザクションに多くの処理を詰め込まず、可能な限り小さく分割することが重要です。

  特に、ユーザーからの入力を待つような処理をトランザクション内に含めることは絶対に避けるべきです。   

- 適切なインデックス設計

  `UPDATE`や`DELETE`文の`WHERE`句がインデックスを適切に使用していない場合、DBMSは意図した行だけでなく、広範囲の行、最悪の場合はテーブル全体をロックしてしまうことがあります。
  
  これによりロックの粒度が大きくなり、デッドロックの可能性が飛躍的に高まります。

  適切なインデックス設計は、ロックを必要最小限の範囲に留めるために不可欠です 。   

## 6.5.2 デッドロックの検出と解消
- データベース管理システム (DBMS) の役割

  予防策を講じても、複雑なシステムではデッドロックを完全に防ぐことは困難です。
  
  そのため、ほとんどの現代的なDBMSには、デッドロックを自動的に検出する機能が備わっています。

  DBMSはバックグラウンドでロックの待ち状態を監視し、循環的な依存関係（デッドロック）を検知すると、一方のトランザクションを「犠牲者（victim）」として選び、強制的にロールバックさせます。

  これによりデッドロックは解消され、もう一方のトランザクションは処理を続行できるようになります 。   

- アプリケーション側での対応(タイムアウトとリトライ処理)

  DBMSがデッドロックを解消すると、犠牲者となったトランザクションを実行していたアプリケーションにはエラーが返されます（例：MySQLのエラーコード1213）。

  アプリケーションは、このデッドロックエラーを単なる失敗として処理するのではなく、一時的な競合状態が原因であると認識し、適切に対応する必要があります。

  一般的な対応策は、エラーを捕捉（catch）し、短いランダムな時間待機した後に、トランザクション全体を再試行（リトライ）することです。

  数回のリトライでも成功しない場合は、最終的にエラーとしてユーザーに通知します 。このリトライ処理を`TRY...CATCH`のような例外処理ブロックに実装することで、デッドロックに対して回復力のある堅牢なアプリケーションを構築できます 。

  このように、デッドロックの管理は、DBMSによる自動解消と、アプリケーションによる賢明なリトライ処理という、両者の連携によって成り立っています。   


# 6.6 トランザクションログとリカバリ
### Write-Ahead Logging (WAL) の原則
データベースの永続性（Durability）と障害回復能力の根幹をなすのが、Write-Ahead Logging（ログ先行書き込み）という原則です。

WALのルールは非常にシンプルです。「データベース本体のデータファイルに変更を加える前に、その変更内容を記述したログレコードを、まず安定したストレージ（ディスク）上のログファイルに書き込まなければならない」というものです 。

これにより、たとえデータの更新中にシステムがクラッシュしても、ログファイルには「何を実行しようとしていたか」という意図の完全な記録が残ります。

このログが、データベースを矛盾のない状態に復旧させるための命綱となります。   

### クラッシュからの復旧プロセス：REDO と UNDO
システム障害後にデータベースが再起動する際、まずトランザクションログを利用したリカバリプロセスが開始されます 。

このプロセスは主に二つのフェーズで構成されます。   

- REDO (再実行) フェーズ

  データベースは、最後のチェックポイント（後述）以降のログを読み進め、ログに記録されている全ての変更処理を再実行します。

  これには、クラッシュ時点でCOMMITされていなかったトランザクションによる変更も含まれます。

  このフェーズの目的は、障害発生によってデータファイルに書き込まれなかった可能性のある、COMMIT済みの変更を確実に反映させることです。

  REDOフェーズが完了すると、データベースはクラッシュ直前の状態（コミット済みデータと未コミットデータが混在した状態）に復元されます。   

- UNDO (取り消し) フェーズ

  次にデータベースは、ログを逆方向にスキャンし、クラッシュ時点でまだCOMMITされていなかった（アクティブだった）トランザクションによる変更をすべて取り消します。

  これにより、中途半端に終わったトランザクションの影響がデータベースから完全に除去され、原子性（Atomicity）と一貫性（Consistency）が保証されます 。   

このREDOとUNDOのプロセスを経て、データベースは「`COMMIT`されたトランザクションの変更はすべて反映され、`COMMIT`されなかったトランザクションの変更はすべて取り消された」という、一貫性のある状態に復旧します。

### チェックポイントの役割(リカバリ時間の短縮)
もし障害からの復旧時に、データベースが運用開始からの全てのトランザクションログを処理する必要があるとしたら、リカバリには膨大な時間がかかってしまいます。

この問題を解決するのがチェックポイントです。

チェックポイントとは、ある特定の時点において、「このポイントより前に`COMMIT`された全てのトランザクションによる変更は、既にデータファイルへ書き込み済みである」ことを保証する、ログ上の目印です 。

DBMSは定期的にこのチェックポイント処理を行い、メモリ上の変更内容をディスクに書き込み、その事実をログに記録します。

これにより、リカバリプロセスはログ全体をスキャンする必要がなくなり、直近のチェックポイントから処理を開始すればよいため、リカバリ時間を劇的に短縮することができるのです 。



# まとめ
本勉強会では、データベースにおけるデータ整合性の核心であるトランザクションについて深く探求しました。最後に、重要な概念を振り返ります。

- トランザクションは、**ACID特性**によってデータの信頼性を保証する、論理的な処理単位です。

- **分離レベル**は、データの一貫性とシステムのパフォーマンスとの間のトレードオフを提供します。アプリケーションの要件に応じて慎重に選択する必要があります。

- ロックは同時実行制御の基本であり、競合の頻度に応じて**悲観的ロック**と**楽観的ロック**を使い分けるべきです。

- **デッドロック**は、リソースの取得順序を統一するなど、適切な設計によって大部分を防ぐことができ、アプリケーションは万一の発生に備えてリトライ処理を実装する必要があります。

- **トランザクションログ**は、システムの障害時にも永続性を保証し、データベースを整合性のとれた状態に復旧させるための安全網です。

これらの概念を深く理解し、実践的な設計に活かすことで、堅牢で信頼性の高いデータベースアプリケーションを構築することが可能になります。





















