# 6. トランザクションとACID特性

# 6.1. トランザクションとは何か
### 処理の「All or Nothing」を保証する論理的な作業単位
トランザクションとは、データベースに対する一連の操作（一つ以上のSQL文）をひとまとめにした、論理的な処理単位のことです 。
トランザクションの最も重要な特性は「原子性（Atomicity）」であり、これは「All or Nothing（すべて実行されるか、一切実行されないか）」の原則を保証することを意味します 。
つまり、トランザクションに含まれる全ての操作が成功した場合にのみ、その結果がデータベースに恒久的に保存されます。
もし一連の操作の途中で何らかのエラーや障害が発生した場合は、それまでに行われた全ての操作が取り消され、データベースはトランザクションが開始される前の状態に完全に戻されます。
この仕組みにより、中途半端な更新処理によってデータが矛盾した状態に陥ることを防ぎます。

### 具体例：銀行振込処理の舞台裏
トランザクションの概念を具体的に理解するために、銀行の口座振込処理を考えてみましょう。

Aさんの口座からBさんの口座へ1万円を送金する場合、システム内部では少なくとも以下の二つの操作が必要です。   

1.Aさんの口座残高から1万円を減らす（UPDATE文）

2.Bさんの口座残高に1万円を加算する（UPDATE文）

もし、1の処理が成功した直後にシステム障害が発生し、2の処理が実行されなかった場合、Aさんの口座から1万円が消えたにもかかわらず、Bさんの口座には入金されません。
これは、全体として1万円が消失したことを意味し、データの整合性が完全に崩壊した状態です。
しかし、これら二つの操作を一つのトランザクションとしてまとめることで、DBMSはその「All or Nothing」を保証します。
障害が発生すれば、Aさんの口座から1万円を減らす操作も自動的に取り消され、お金が消えるという事態を防ぐことができるのです。
このようにトランザクションは、現実世界のビジネスルールをデータベース上で安全に実現するための不可欠な仕組みです。

<img width="846" height="616" alt="スクリーンショット 2025-08-17 21 32 23" src="https://github.com/user-attachments/assets/598d0b2d-a811-4b80-baa2-01a567d1a46b" />

### `COMMIT` と `ROLLBACK` 変更の確定と破棄
トランザクションのライフサイクルは、二つの基本的なコマンドによって制御されます。

- `COMMIT`

  トランザクション内の全ての操作が正常に完了したことを宣言し、その変更をデータベースに恒久的に反映させる命令です。
  COMMITが実行されると、変更内容は確定し、他のトランザクションからも参照可能になります。

- `ROLLBACK`

  トランザクション内でエラーが発生した場合や、処理を意図的に中断したい場合に、それまでに行った全ての変更を破棄し、データベースをトランザクション開始前の状態に戻す命令です 。これが「Nothing」の部分を強制するメカニズムです。   

開発者は、一連のビジネスロジックの成功をもって`COMMIT`を実行し、途中で問題が検知された場合には`ROLLBACK`を実行することで、データの整合性を能動的に管理します。

# 6.2 ACID特性の詳細：信頼性の四原則
トランザクションがデータベースの信頼性を保証するために備えるべき4つの重要な性質は、それぞれの頭文字をとってACID特性と呼ばれます。
これらの特性は、データベースシステムが予期せぬ障害やエラーに直面しても、データの完全性を維持するための基盤となります 。
ここでは、料理教室の例えを用いて直感的なイメージを掴んだ後、各特性を技術的に詳述します 。   

- 原子性 (Atomicity): レシピの全工程を完璧にこなすこと。途中で失敗したら最初からやり直し。

- 一貫性 (Consistency): 教室のルール（アレルギー食材は使わない等）を常に守ること。

- 独立性 (Isolation): 他の生徒の作業が自分の料理に影響を与えないこと。

- 永続性 (Durability): 完成した料理を冷蔵庫にしっかり保存し、失われないようにすること。

## 6.2.1 Atomicity (原子性): 不可分な操作
- 定義と技術的実現

  原子性とは、前述の通りトランザクションが「All or Nothing」で実行されることを保証する性質です。

  技術的には、これは主にトランザクションログを用いて実現されます。

  データベース本体のデータを直接変更する前に、まず「これからどのような変更を行うか」という操作内容をログファイルに記録します。

  もしトランザクションが中断（アボート）された場合、DBMSはこのログを逆方向に辿り、実行された操作を取り消す（UNDO）ことで、データベースを矛盾のない状態に戻します 。   

- シナリオ(原子性が失われた場合の問題点)

  銀行振込の例で原子性が保証されない場合、送金元口座からの引き落としは完了したが、システムクラッシュにより送金先口座への入金が行われない、という事態が発生します。
  結果として、顧客の資産が失われ、データベースは不整合な状態に陥ります。
  原子性は、トランザクションにおける整合性の最も基本的な保証です。

## 6.2.2 Consistency (一貫性): 常に正しい状態へ
- 定義とデータベース制約との関係

  一貫性とは、トランザクションの実行前後において、データベースが常に「正当な（valid）」状態を維持することを保証する性質です 。
  これは他の3つの特性よりも広範な概念であり、データの値がデータベースに予め定義されたルールや制約（例：NOT NULL制約、一意性制約、外部キー制約、CHECK制約など）を常に満たしていることを意味します 。
  トランザクション自体がビジネスロジックとして正しく記述されていることが前提であり、データベースはその正しいトランザクションが実行された結果、データ全体の整合性が保たれることを保証します。   

- シナリオ(一貫性が崩壊する例)

  例えば、商品の在庫が5つしかないのに10個の注文を受け付けるトランザクションや、存在しない顧客IDに対して注文を作成するトランザクションは、一貫性を破壊します。
  適切に設計されたデータベースでは、在庫数に対するCHECK制約や、顧客テーブルへの外部キー制約によってこのような不正なトランザクションは拒否され、一貫性が維持されます 。
  一貫性は、データベースが提供するA, I, Dという仕組みと、開発者が記述する正しいビジネスロジックとの共同責任によって達成される目標と言えます。

## 6.2.3 Isolation (独立性): 干渉からの保護
- 定義と同時実行の問題

  独立性（分離性とも呼ばれる）は、複数のトランザクションが同時に実行されたとしても、互いに干渉することなく、あたかも各トランザクションが単独で実行されているかのように振る舞うことを保証する性質です 。
  これは、特に多人数が同時にシステムを利用する環境において、データの破損を防ぐために極めて重要です。  

- シナリオ(独立性が確保されない場合のデータ破損)

  航空券予約システムで、最後の1席を2人のユーザーが同時に予約しようとするケースを考えます。
  独立性がなければ、両方のトランザクションが「残席1」という情報を読み取り、それぞれが予約を成功させてしまう可能性があります。
  結果として、座席はダブルブッキングされ、航空会社は深刻な問題に直面します。
  独立性はこの問題を、一方のトランザクションが完了して座席を確保するまで、もう一方のトランザクションからはその途中経過が見えないようにすることで防ぎます。   

## 6.2.4 Durability (永続性): 失われない結果
- 定義と物理的保存の保証

  永続性とは、一度`COMMIT`されたトランザクションの結果は、その後にシステム障害（例：電源断、OSクラッシュ）が発生したとしても失われることはなく、恒久的にデータベースに保存されることを保証する性質です 。
  これは、トランザクションの変更内容が、`COMMIT`の成功をクライアントに通知する前に、ディスクなどの不揮発性ストレージ上のログファイルに書き込まれることで実現されます 。   

- シナリオ(永続性がなければ何が起こるか)

  ユーザーがオンラインショッピングで注文を確定し、システムから「注文完了」の通知を受け取ったとします。
  その直後にサーバーが停電した場合、永続性がなければ、サーバー再起動後にその注文データが消失している可能性があります。
  しかし、ユーザーのクレジットカード決済は既に処理されているかもしれません。
  永続性は、一度確定した注文情報が確実に保存されることを保証し、このような悲惨な事態を防ぎます 。


# 6.3 同時実行制御とロック機構
### なぜ同時実行制御が必要なのか？
複数のトランザクションを一つずつ順番に実行（直列実行）すれば、独立性は完全に保証されます。
しかし、それではシステムの処理性能が極端に低下し、多くのユーザーが同時に利用する現代のアプリケーションでは現実的ではありません。
同時実行制御とは、複数のトランザクションを並行して実行させつつ、ロックなどの仕組みを用いて互いの干渉を防ぎ、あたかも直列に実行されているかのような結果の正しさを保証するための技術です。
これにより、システムのパフォーマンスとデータ整合性の両立を図ります 。   

### ロックの基本：共有ロック (Shared Lock) と専有ロック (Exclusive Lock)
同時実行制御の最も基本的な仕組みがロックです。
ロックは、あるトランザクションがデータにアクセスしている間、他のトランザクションからのアクセスを制限することで排他制御を実現します 。   

- 共有ロック (Shared Lock / S-Lock)

  データを読み取る際に獲得するロックです。
  「読み取りロック」とも呼ばれます。共有ロックは他のトランザクションが同じデータに対して共有ロックを獲得することを許可しますが、専有ロックの獲得はブロックします。
  つまり、複数のユーザーが同時に同じデータを読み取ることはできます。

- 専有ロック (Exclusive Lock / X-Lock)

  データを変更（INSERT, UPDATE, DELETE）する際に獲得するロックです。
  「書き込みロック」とも呼ばれます。専有ロックがかけられているデータに対しては、他のトランザクションは共有ロックも専有ロックも獲得できず、読み書き両方がブロックされます 。   

この二つのロックの互換性（Sロック同士は両立するが、Xロックは他のいかなるロックとも両立しない）が、データベースにおける排他制御の根幹をなしています 。   

## 6.3.1 悲観的並行制御 (Pessimistic Concurrency Control)
- 思想：「衝突は起こるもの」

  悲観的ロックは、トランザクション間でデータ更新の競合が頻繁に発生するという前提に立つアプローチです。
  そのため、データを変更する前にまず対象のデータをロックし、他のトランザクションがアクセスできないようにしてから処理を開始します。
  競合の発生を悲観的に予測し、未然に防ぐための手法です 。   

- 実装例(`SELECT... FOR UPDATE`の詳細な解説)

  悲観的ロックを実装する最も一般的な方法は、`SELECT... FOR UPDATE`構文を使用することです。
  このSQL文は、データを読み取ると同時に、その行に対して専有ロック（X-Lock）を獲得します 。これにより、現在のトランザクションが`COMMIT`または`ROLLBACK`するまで、他のトランザクションは対象行を変更したり、同様にロックをかけたりすることができなくなります 。   

<img width="786" height="228" alt="スクリーンショット 2025-08-19 0 51 13" src="https://github.com/user-attachments/assets/7d5d6e6b-9533-4110-bf2a-b6c660a7f922" />

この構文は必ずトランザクションブロック内で使用する必要があり、ロックの保持時間を最小限にするため、処理が完了したら速やかにトランザクションを終了することが重要です。
また、WHERE句の条件がインデックスを利用しない場合、行ロックではなくテーブル全体がロックされてしまう危険性があるため、インデックス設計が極めて重要になります 。   

## 6.3.2 楽観的並行制御 (Optimistic Concurrency Control)
- 思想：「衝突は稀である」

  楽観的ロックは、データ更新の競合はめったに発生しないという前提に立つアプローチです。
  そのため、データ読み取り時にはロックをかけません。
  代わりに、読み取ったデータを実際に更新しようとする段階で、そのデータが他のトランザクションによって変更されていないかを確認します。
  競合の発生を楽観的に捉え、もし発生していた場合にそれを検知する手法です 。   

- 実装例：バージョンカラムを用いた更新手法:

  楽観的ロックの一般的な実装パターンは、バージョン管理カラムを使用する方法です。

1. 対象のテーブルに`version`のような整数型のカラムを追加します 。   

2. アプリケーションがデータを読み込む際、`version`カラムの値も一緒に取得します。

3. データを更新する際、`UPDATE`文の`WHERE`句に、読み込み時と同じ`version`番号であることを条件として加えます。

4. `UPDATE`文では、`version`カラムの値を1つインクリメントします。

<img width="782" height="195" alt="スクリーンショット 2025-08-19 0 57 07" src="https://github.com/user-attachments/assets/4fc4549a-7296-42b0-8653-801381c67ec0" />

もしこのUPDATE文の実行結果が1行更新であれば、競合は発生しておらず、更新は成功です。
もし結果が0行更新であれば、読み込んでから更新するまでの間に他のトランザクションがデータを更新し、version番号が変わってしまったことを意味します。
この場合、更新は失敗したと判断し、アプリケーションはトランザクションをロールバックして、データの再読み込みから処理をやり直す（リトライする）必要があります。   

悲観的ロック vs 楽観的ロック 比較表

<img width="679" height="181" alt="スクリーンショット 2025-08-19 0 58 10" src="https://github.com/user-attachments/assets/1deee01c-8721-4c8b-8089-955ca944b0d8" />


6.4 分離レベル (Isolation Level)
6.4.1 同時実行で発生する異常現象
独立性（Isolation）を完全に保証するとパフォーマンスが低下するため、多くのデータベースでは、その保証レベルを意図的に緩和することが許されています。この保証レベルを「分離レベル（Isolation Level）」と呼びます。分離レベルが低いほど、パフォーマンスは向上しますが、以下のようなデータ不整合を引き起こす「異常現象」が発生する可能性があります 。   

ダーティリード (Dirty Read): あるトランザクションがまだCOMMITしていない変更途中のデータを、別のトランザクションが読み込んでしまう現象。もし変更元のトランザクションがROLLBACKされた場合、読み取ったデータは「存在しなかった」ことになり、深刻な不整合を引き起こします 。   

ノンリピータブルリード (Non-Repeatable Read / Fuzzy Read): あるトランザクションが同じ行を2回読み込んだ際に、1回目と2回目の間で別のトランザクションがその行を更新・COMMITしたため、異なるデータが返ってくる現象。同じトランザクション内での読み取り結果が再現できないことを意味します 。   

ファントムリード (Phantom Read): あるトランザクションが特定の条件で複数行を検索した後、再度同じ条件で検索した際に、別のトランザクションがその条件に合致する新しい行を挿入・COMMITしたため、以前は存在しなかった「幽霊（Phantom）」のような行が見えてしまう現象。検索結果の行数が変わってしまいます 。   

6.4.2 標準的な4つの分離レベル
SQL規格では、これらの異常現象をどこまで許容するかに応じて、4つの分離レベルが定義されています 。   

READ UNCOMMITTED (リード アンコミッティド): 最も分離レベルが低い。ダーティリード、ノンリピータブルリード、ファントムリードの全てが発生する可能性があります。パフォーマンスは最も高いですが、整合性の保証は最小限です。

READ COMMITTED (リード コミッティド): ダーティリードを防ぎます。つまり、COMMITされたデータしか読み取れません。しかし、ノンリピータブルリードとファントムリードは発生する可能性があります。多くのデータベース（PostgreSQL, Oracleなど）でデフォルトの分離レベルです。

REPEATABLE READ (リピータブル リード): ダーティリードとノンリピータブルリードを防ぎます。同じトランザクション内であれば、同じ行を何度読み込んでも同じ結果が保証されます。しかし、ファントムリードは発生する可能性があります。MySQL (InnoDB) のデフォルト分離レベルです 。   

SERIALIZABLE (シリアライザブル): 最も分離レベルが高い。全ての異常現象を防ぎます。トランザクションが完全に直列で実行されたかのような結果を保証します。整合性は最も高いですが、ロックが厳しくなるためパフォーマンスへの影響も最も大きくなります 。   

6.4.3 パフォーマンスと整合性のトレードオフ
分離レベルの選択は、アプリケーションの要件におけるパフォーマンスとデータ整合性の間の重要なトレードオフです 。分離レベルを高く設定するほど、データベースはより厳格で長期間にわたるロックを取得するため、同時実行性が低下し、システムの全体的なスループットは下がります 。逆に、分離レベルを低くすれば、ロックの競合が減りパフォーマンスは向上しますが、アプリケーション側でデータ不整合が発生する可能性を考慮したコーディングが必要になります。例えば、厳密な会計処理を行うシステムでは   

SERIALIZABLEが求められるかもしれませんが、最新情報が表示されれば多少の不整合は許容できるSNSのタイムラインのような機能ではREAD COMMITTEDで十分な場合もあります。

Table: 分離レベルと発生しうる異常現象の対応表
分離レベル	ダーティリード	ノンリピータブルリード	ファントムリード
READ UNCOMMITTED	発生する	発生する	発生する
READ COMMITTED	発生しない	発生する	発生する
REPEATABLE READ	発生しない	発生しない	発生する
SERIALIZABLE	発生しない	発生しない	発生しない
   

# 6.5 デッドロックとその対処法
### デッドロックの発生メカニズム
デッドロックとは、2つ以上のトランザクションが、互いに相手が保持しているロックの解放を待ち続けることで、永久に処理が進まなくなってしまう状態のことです 。
この膠着状態は、以下のような典型的なシナリオで発生します。   

1. トランザクションAが、リソースX（例：productsテーブルの行1）のロックを獲得する。

2. ほぼ同時に、トランザクションBが、リソースY（例：stockテーブルの行5）のロックを獲得する。

3. トランザクションAが、次にリソースYのロックを獲得しようとするが、Bが保持しているため待機状態に入る。

4. トランザクションBが、次にリソースXのロックを獲得しようとするが、Aが保持しているため待機状態に入る。

この結果、AはBの終了を待ち、BはAの終了を待つという循環的な待ち状態が生まれ、
どちらのトランザクションも外部からの介入なしには進むことができなくなります。

## 6.5.1 デッドロックの予防策
デッドロックへの最善の対処法は、そもそもデッドロックが発生しにくいシステムを設計することです 。   

- リソース取得順序の統一

  これが最も効果的な予防策です。
  複数のリソースをロックする必要がある場合、全てのトランザクションが必ず同じ順序（例：常にテーブルA→テーブルBの順）でロックを取得するようにアプリケーションを設計します。
  これにより、前述のような循環的な待ち状態が発生するのを防ぐことができます 。   

- トランザクションの短期化とスコープの最小化

  トランザクションがロックを保持する時間が短ければ短いほど、他のトランザクションと衝突する機会は減ります。
  一つのトランザクションに多くの処理を詰め込まず、可能な限り小さく分割することが重要です。
  特に、ユーザーからの入力を待つような処理をトランザクション内に含めることは絶対に避けるべきです。   

- 適切なインデックス設計

  `UPDATE`や`DELETE`文の`WHERE`句がインデックスを適切に使用していない場合、DBMSは意図した行だけでなく、広範囲の行、最悪の場合はテーブル全体をロックしてしまうことがあります。
  これによりロックの粒度が大きくなり、デッドロックの可能性が飛躍的に高まります。
  適切なインデックス設計は、ロックを必要最小限の範囲に留めるために不可欠です 。   

## 6.5.2 デッドロックの検出と解消
- データベース管理システム (DBMS) の役割

  予防策を講じても、複雑なシステムではデッドロックを完全に防ぐことは困難です。
  そのため、ほとんどの現代的なDBMSには、デッドロックを自動的に検出する機能が備わっています。
  DBMSはバックグラウンドでロックの待ち状態を監視し、循環的な依存関係（デッドロック）を検知すると、一方のトランザクションを「犠牲者（victim）」として選び、強制的にロールバックさせます。
  これによりデッドロックは解消され、もう一方のトランザクションは処理を続行できるようになります 。   

- アプリケーション側での対応(タイムアウトとリトライ処理)

  DBMSがデッドロックを解消すると、犠牲者となったトランザクションを実行していたアプリケーションにはエラーが返されます（例：MySQLのエラーコード1213）。
  アプリケーションは、このデッドロックエラーを単なる失敗として処理するのではなく、一時的な競合状態が原因であると認識し、適切に対応する必要があります。
  一般的な対応策は、エラーを捕捉（catch）し、短いランダムな時間待機した後に、トランザクション全体を再試行（リトライ）することです。
  数回のリトライでも成功しない場合は、最終的にエラーとしてユーザーに通知します 。このリトライ処理を`TRY...CATCH`のような例外処理ブロックに実装することで、デッドロックに対して回復力のある堅牢なアプリケーションを構築できます 。
  このように、デッドロックの管理は、DBMSによる自動解消と、アプリケーションによる賢明なリトライ処理という、両者の連携によって成り立っています。   

# 6.6 トランザクションログとリカバリ
### Write-Ahead Logging (WAL) の原則
データベースの永続性（Durability）と障害回復能力の根幹をなすのが、Write-Ahead Logging（ログ先行書き込み）という原則です。
WALのルールは非常にシンプルです。
「データベース本体のデータファイルに変更を加える前に、その変更内容を記述したログレコードを、まず安定したストレージ（ディスク）上のログファイルに書き込まなければならない」というものです 。
これにより、たとえデータの更新中にシステムがクラッシュしても、ログファイルには「何を実行しようとしていたか」という意図の完全な記録が残ります。
このログが、データベースを矛盾のない状態に復旧させるための命綱となります。   

### クラッシュからの復旧プロセス：REDO と UNDO
システム障害後にデータベースが再起動する際、まずトランザクションログを利用したリカバリプロセスが開始されます 。
このプロセスは主に二つのフェーズで構成されます。   

- REDO (再実行) フェーズ
  
  データベースは、最後のチェックポイント（後述）以降のログを読み進め、ログに記録されている全ての変更処理を再実行します。
  これには、クラッシュ時点でCOMMITされていなかったトランザクションによる変更も含まれます。
  このフェーズの目的は、障害発生によってデータファイルに書き込まれなかった可能性のある、COMMIT済みの変更を確実に反映させることです。
  REDOフェーズが完了すると、データベースはクラッシュ直前の状態（コミット済みデータと未コミットデータが混在した状態）に復元されます。   

- UNDO (取り消し) フェーズ

  次にデータベースは、ログを逆方向にスキャンし、クラッシュ時点でまだCOMMITされていなかった（アクティブだった）トランザクションによる変更をすべて取り消します。
  これにより、中途半端に終わったトランザクションの影響がデータベースから完全に除去され、原子性（Atomicity）と一貫性（Consistency）が保証されます 。   

このREDOとUNDOのプロセスを経て、データベースは「`COMMIT`されたトランザクションの変更はすべて反映され、`COMMIT`されなかったトランザクションの変更はすべて取り消された」という、一貫性のある状態に復旧します。

### チェックポイントの役割(リカバリ時間の短縮)
もし障害からの復旧時に、データベースが運用開始からの全てのトランザクションログを処理する必要があるとしたら、リカバリには膨大な時間がかかってしまいます。
この問題を解決するのがチェックポイントです。
チェックポイントとは、ある特定の時点において、「このポイントより前に`COMMIT`された全てのトランザクションによる変更は、既にデータファイルへ書き込み済みである」ことを保証する、ログ上の目印です 。
DBMSは定期的にこのチェックポイント処理を行い、メモリ上の変更内容をディスクに書き込み、その事実をログに記録します。
これにより、リカバリプロセスはログ全体をスキャンする必要がなくなり、直近のチェックポイントから処理を開始すればよいため、リカバリ時間を劇的に短縮することができるのです 。



# まとめ
本勉強会では、データベースにおけるデータ整合性の核心であるトランザクションについて深く探求しました。最後に、重要な概念を振り返ります。

- トランザクションは、**ACID特性**によってデータの信頼性を保証する、論理的な処理単位です。

- **分離レベル**は、データの一貫性とシステムのパフォーマンスとの間のトレードオフを提供します。アプリケーションの要件に応じて慎重に選択する必要があります。

- ロックは同時実行制御の基本であり、競合の頻度に応じて**悲観的ロック**と**楽観的ロック**を使い分けるべきです。

- **デッドロック**は、リソースの取得順序を統一するなど、適切な設計によって大部分を防ぐことができ、アプリケーションは万一の発生に備えてリトライ処理を実装する必要があります。

- **トランザクションログ**は、システムの障害時にも永続性を保証し、データベースを整合性のとれた状態に復旧させるための安全網です。

これらの概念を深く理解し、実践的な設計に活かすことで、堅牢で信頼性の高いデータベースアプリケーションを構築することが可能になります。












