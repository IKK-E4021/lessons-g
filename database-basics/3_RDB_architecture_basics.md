# 3 リレーショナルデータベース基本アーキテクチャ - 導入・全体像

## はじめに

リレーショナルデータベース管理システム（RDBMS）は、現代のビジネスアプリケーションの中核を担う重要な技術です。Web サービス、基幹システム、モバイルアプリケーションなど、あらゆるシステムの背後でデータの永続化と管理を担っています。

しかし、多くの開発者や運用担当者は、RDBMSを「ブラックボックス」として扱い、その内部構造について深く理解することなく使用しているのが現状です。本セッションでは、RDBMSの内部アーキテクチャを体系的に理解することで、より効果的なデータベース設計と運用を実現することを目指します。

## RDBMSの役割と重要性

### データベース管理システムの4つの役割

**データの永続化**
アプリケーション終了後もデータを安全に保持し、再起動時に復元する

**同時実行制御**
複数のユーザーが同時にアクセスしても、データの整合性を保つ

**整合性保証**
ACID特性（原子性・一貫性・独立性・永続性）によるデータの信頼性確保

**効率的なアクセス**
インデックスやキャッシュ機能による高速なデータ検索・更新

### なぜ「ブラックボックス」ではダメなのか

内部構造を知らないと以下の問題が発生します：

- 問題の根本原因を特定できない
- 適切なパフォーマンス・チューニングができない
- 障害時の復旧手順が分からない
- 監視すべき項目が分からない


## 実際の問題例　「なぜアプリが急に重くなったのか？」

昨日まで正常だったシステムが突然レスポンス5秒以上に悪化。CPUもメモリも余裕があるのに重い。「とりあえずサーバー再起動」で一時的に改善するが、根本原因が分からない。

### 考えられる原因
- **バッファプールのヒット率低下**：メモリ上のデータが不足
- **ログファイルの切り替え処理**：WALログの書き込み待機
- **インデックスの断片化**：効率的な検索ができない状態
- **接続数の増加**：コンテキストスイッチによるオーバーヘッド

これらの原因を特定するには、データベースの内部構造の理解が不可欠です。


## アーキテクチャを理解することの意義

### 1. 問題解決力の向上

**Before（症状ベース）**
「アプリが遅い」→「サーバーを再起動してみよう」

**After（原因ベース）**
「レスポンスが遅い」→「バッファヒット率をチェック」→「メモリ不足が原因」→「適切なメモリ増設」

適切な監視項目を設定し、効果的な対策を選択できるようになります。

### 2. 予防保全の実現

問題が発生してから対応するのではなく、兆候を事前に察知できます：

- キャパシティプランニングの精度向上
- 適切な設定変更による事前対策
- 定期メンテナンスの効果的な実施

### 3. 技術選択の根拠

なんとなくではなく、明確な理由を持って技術選択ができます：

- **PostgreSQL vs MySQL**：トランザクション処理の違いを理解した選択
- **ストレージ選択**：ランダムアクセス特性を考慮したSSD vs HDD判断
- **クラウドDBサービス**：内部アーキテクチャを理解した上での活用


# 2. クライアント・サーバーモデル

## データベース接続の基本構造

### クライアント・サーバーアーキテクチャとは

**クライアント側**
- アプリケーション（Webサーバー、業務アプリケーション）
- データベースドライバー（JDBC、ODBC、PDO等）
- 接続要求の送信とクエリ実行

**サーバー側**
- データベースサーバープロセス
- 接続受付とセッション管理
- クエリ処理とレスポンス返却

### 接続プロセスの流れ

1. **接続要求**：クライアントがサーバーに接続を要求
2. **認証**：ユーザー名・パスワードの検証
3. **セッション確立**：専用の接続チャネルを作成
4. **クエリ送信**：SQLクエリをサーバーに送信
5. **結果返却**：処理結果をクライアントに返送
6. **接続終了**：セッションをクリーンアップ

---

## 接続数上限によるアプリケーションエラー

### 実際の問題例

平日朝9時頃にWebアプリケーションで以下のエラーが多発：
```
Connection refused: too many connections
Can't connect to MySQL server
```

**症状**
- 新規ログインができない
- 既存セッションは正常動作
- サーバーリソース（CPU・メモリ）には余裕あり

### 根本原因

**MySQLの接続数制限**
- デフォルト設定：max_connections = 151
- 朝の利用ピーク時：同時接続数が上限を超過
- アプリケーションの接続管理不備

**一般的な原因**
- コネクションプールの設定不備
- アプリケーションでの接続リークバグ
- 長時間実行クエリによる接続占有
- 適切な接続数設定の不足

---

## コネクションプールの重要性

### コネクションプールなしの問題

**接続コストの問題**
- 毎回のTCP接続確立：ネットワークオーバーヘッド
- 認証処理：セキュリティチェックの時間
- セッション初期化：設定値の読み込み

**リソース使用効率の悪化**
- 接続・切断の繰り返し：CPUリソースの無駄
- 同時接続数の急激な変動：サーバー負荷の不安定化

### コネクションプールによる解決

**効果**
- **接続再利用**：確立済み接続の使い回し
- **接続数制御**：最大接続数による制限
- **レスポンス向上**：接続確立時間の削減
- **リソース効率化**：安定した接続数の維持

**主要な設定パラメータ**
- **初期接続数**：アプリ起動時に確保する接続数
- **最大接続数**：プール内の最大接続数
- **最小アイドル数**：常に保持する最小接続数
- **接続タイムアウト**：接続取得待ちの制限時間

---

## 接続方式の種類と特徴

### 専用接続（Dedicated Connection）

**特徴**
- 1クライアント = 1サーバープロセス
- PostgreSQLで採用
- 接続ごとに独立したメモリ空間

**メリット・デメリット**
- ✅ プロセス間の独立性が高い
- ✅ 1つのプロセス異常が他に影響しない
- ❌ メモリ使用量が多い
- ❌ プロセス生成コストが高い

### 共有接続（Shared Connection）

**特徴**
- 複数クライアント = 1サーバープロセス
- MySQLのスレッドプールで採用
- スレッド間でメモリ共有

**メリット・デメリット**
- ✅ メモリ効率が良い
- ✅ コンテキストスイッチが軽量
- ❌ スレッド間の影響リスク
- ❌ 排他制御の複雑性

---

## 監視と対策

### 重要な監視項目

**接続数の監視**
```sql
-- MySQL
SHOW STATUS LIKE 'Threads_connected';
SHOW VARIABLES LIKE 'max_connections';

-- PostgreSQL
SELECT count(*) FROM pg_stat_activity;
```

**接続プールの状態**
- アクティブ接続数
- アイドル接続数
- 接続待ちキューの長さ
- 接続取得失敗回数

### 予防策と対処法

**設定の最適化**
- 適切な最大接続数の設定
- コネクションプールサイズの調整
- 接続タイムアウト値の設定

**アプリケーション側の対策**
- 確実な接続クローズ処理
- try-with-resources文の活用
- 接続リーク検知の仕組み導入

**緊急時の対処**
- 長時間実行クエリの強制終了
- 不要な接続の手動切断
- 接続数上限の一時的な増加

# 2. クライアント・サーバーモデル

## データベース接続の基本構造

### クライアント・サーバーアーキテクチャとは

**クライアント側**
- アプリケーション（Webサーバー、業務アプリケーション）
- データベースドライバー（JDBC、ODBC、PDO等）
- 接続要求の送信とクエリ実行

**サーバー側**
- データベースサーバープロセス
- 接続受付とセッション管理
- クエリ処理とレスポンス返却

### 接続プロセスの流れ

1. **接続要求**：クライアントがサーバーに接続を要求
2. **認証**：ユーザー名・パスワードの検証
3. **セッション確立**：専用の接続チャネルを作成
4. **クエリ送信**：SQLクエリをサーバーに送信
5. **結果返却**：処理結果をクライアントに返送
6. **接続終了**：セッションをクリーンアップ



## 接続数上限によるアプリケーションエラー

### 実際の問題例

平日朝9時頃にWebアプリケーションで以下のエラーが多発：
```
Connection refused: too many connections
Can't connect to MySQL server
```

**症状**
- 新規ログインができない
- 既存セッションは正常動作
- サーバーリソース（CPU・メモリ）には余裕あり

### 根本原因

**MySQLの接続数制限**
- デフォルト設定：max_connections = 151
- 朝の利用ピーク時：同時接続数が上限を超過
- アプリケーションの接続管理不備

**一般的な原因**
- コネクションプールの設定不備
- アプリケーションでの接続リークバグ
- 長時間実行クエリによる接続占有
- 適切な接続数設定の不足

## コネクションプールの重要性

### コネクションプールなしの問題

**接続コストの問題**
- 毎回のTCP接続確立：ネットワークオーバーヘッド
- 認証処理：セキュリティチェックの時間
- セッション初期化：設定値の読み込み

**リソース使用効率の悪化**
- 接続・切断の繰り返し：CPUリソースの無駄
- 同時接続数の急激な変動：サーバー負荷の不安定化

### コネクションプールによる解決

**効果**
- **接続再利用**：確立済み接続の使い回し
- **接続数制御**：最大接続数による制限
- **レスポンス向上**：接続確立時間の削減
- **リソース効率化**：安定した接続数の維持

**主要な設定パラメータ**
- **初期接続数**：アプリ起動時に確保する接続数
- **最大接続数**：プール内の最大接続数
- **最小アイドル数**：常に保持する最小接続数
- **接続タイムアウト**：接続取得待ちの制限時間

## 接続方式の種類と特徴

### 専用接続（Dedicated Connection）

**特徴**
- 1クライアント = 1サーバープロセス
- PostgreSQLで採用
- 接続ごとに独立したメモリ空間

**メリット・デメリット**
- ✅ プロセス間の独立性が高い
- ✅ 1つのプロセス異常が他に影響しない
- ❌ メモリ使用量が多い
- ❌ プロセス生成コストが高い

### 共有接続（Shared Connection）

**特徴**
- 複数クライアント = 1サーバープロセス
- MySQLのスレッドプールで採用
- スレッド間でメモリ共有

**メリット・デメリット**
- ✅ メモリ効率が良い
- ✅ コンテキストスイッチが軽量
- ❌ スレッド間の影響リスク
- ❌ 排他制御の複雑性

## 監視と対策

### 重要な監視項目

**接続数の監視**
```sql
-- MySQL
SHOW STATUS LIKE 'Threads_connected';
SHOW VARIABLES LIKE 'max_connections';

-- PostgreSQL
SELECT count(*) FROM pg_stat_activity;
```

**接続プールの状態**
- アクティブ接続数
- アイドル接続数
- 接続待ちキューの長さ
- 接続取得失敗回数

### 予防策と対処法

**設定の最適化**
- 適切な最大接続数の設定
- コネクションプールサイズの調整
- 接続タイムアウト値の設定

**アプリケーション側の対策**
- 確実な接続クローズ処理
- try-with-resources文の活用
- 接続リーク検知の仕組み導入

**緊急時の対処**
- 長時間実行クエリの強制終了
- 不要な接続の手動切断
- 接続数上限の一時的な増加